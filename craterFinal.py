# -*- coding: utf-8 -*-
"""craterFinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XGmHGN5TolXCfhd1xbQ-u7KWd58nXbU1

# Descenso al fondo de un cráter en Marte

Francisco Javier Chávez Ochoa A01641644

Miguel Emiliano González Gauna A01633816

Laura Merarí Valdivia Frausto A01641790
"""

import numpy as np
mars_map = np.load('mars_map (1) (1).npy')
mars_map.shape

import numpy as np
import plotly.graph_objs as go
import plotly.io as pio

import math
import time
import random

# Definir la clase MazeState
class crater(object):
    
    
    def __init__(self, r, c,mapa):        
      
        self.r = r
        self.c = c
        self.mapa=mapa
        
  
    def cost(self):
        
        return self.mapa[self.r][self.c]

    def neighbor(self):
      
      vecino=[]
      if abs(mars_map[self.r][self.c+1]- mars_map[self.r][self.c])<= 2:
        vecino.append([self.r, self.c+1])

      if abs(mars_map[self.r][self.c-1]- mars_map[self.r][self.c]) <=2:
        vecino.append([self.r, self.c-1])

      if abs(mars_map[self.r+1][self.c+1]- mars_map[self.r][self.c]) <=2:
        vecino.append([self.r+1, self.c+1])

      if abs(mars_map[self.r+1][self.c]- mars_map[self.r][self.c]) <=2:
        vecino.append([self.r+1, self.c])
      
      if abs(mars_map[self.r+1][self.c-1]- mars_map[self.r][self.c]) <=2:
        vecino.append([self.r+1, self.c-1])
      
      if abs(mars_map[self.r-1][self.c+1]- mars_map[self.r][self.c]) <=2:
        vecino.append([self.r-1, self.c+1])
      
      if abs(mars_map[self.r-1][self.c]- mars_map[self.r][self.c]) <=2:
        vecino.append([self.r-1, self.c])
      
      if abs(mars_map[self.r-1][self.c-1]- mars_map[self.r][self.c]) <=2:
        vecino.append([self.r-1, self.c-1])
      
      vecino_random=random.choice(vecino)
      new_map=crater(vecino_random[0], vecino_random[1], self.mapa)

      return new_map

nr, nc = mars_map.shape
scale = 10.045

r = nr-round(5800/scale)
c =round(3350/scale)

"""# Greedy Search"""

random.seed(time.time()*1000)

mapa_crater= crater(r,c,mars_map)      # Initialize board
   

cost = mapa_crater.cost()         # Initial cost    
step = 0   
path1_r=[]
path1_c=[]
while  step<10000 and cost > 0:

    step += 1
    neighbor = mapa_crater.neighbor()
    new_cost = neighbor.cost()

    if new_cost < cost:
      mapa_crater = neighbor
      cost = new_cost

    
    path1_r.append(mapa_crater.r)
    path1_c.append(mapa_crater.c)

    
    print("Iteration: ", step, "    Cost: ", cost)



print("--------Solution-----------")

"""# Recocido Simulado"""

random.seed(time.time()*1000)

mapa_crater = crater(r,c,mars_map)      # Initialize board  
dic={}
cost = mapa_crater.cost()               # Initial cost    
step = 0                                # Step count

alpha = 0.9995                          # Coefficient of the exponential temperature schedule        
t0 = 20                                 # Initial temperature
t = t0   

path2_r=[]
path2_c=[]
while t > 0.005 and cost > 0:

    # Calculate temperature
    t = t0 * math.pow(alpha, step)
    step += 1
        
    # Get random neighbor
    neighbor = mapa_crater.neighbor()
    new_cost = neighbor.cost()

    
    if new_cost < cost:
        mapa_crater = neighbor
        cost = new_cost
    else:
        # Calculate probability of accepting the neighbor
        p = math.exp(-(new_cost - cost)/t)
        if p >= random.random():
            mapa_crater = neighbor
            cost = new_cost    

    
    path2_r.append(mapa_crater.r)
    path2_c.append(mapa_crater.c)
    #if step%100 ==1:
    print("Iteration: ", step, "    Cost: ", cost, "    Temperature: ", t)

path_x1 = np.array([p for p in path1_c])*scale
path_y1 = (nr-np.array([p for p in path1_r]))*scale
path_z1 = np.array([mars_map[path1_r[j]][path1_c[j]] for j in range(len(path1_r))])

path_x2 = np.array([p for p in path2_c])*scale
path_y2 = (nr-np.array([p for p in path2_r]))*scale
path_z2 = np.array([mars_map[path2_r[j]][path2_c[j]] for j in range(len(path2_c))])

x = scale*np.arange(mars_map.shape[1])
y = scale*np.arange(mars_map.shape[0])
X, Y = np.meshgrid(x, y)

fig = go.Figure(data=[
            go.Surface(
                x=X, y=Y, z=np.flipud(mars_map), colorscale='hot', cmin=0, 
                lighting=dict(ambient=0.0, diffuse=0.8, fresnel=0.02, roughness=0.4, specular=0.2),
                lightposition=dict(x=0, y=nr/2, z=2*mars_map.max())
            ),
            go.Scatter3d(
                x=path_x1, y=path_y1, z=path_z1, name='Greedy', mode='markers', 
                marker=dict(color=np.linspace(0, 1, len(path_x1)), colorscale="Viridis", size=4)
            ),
            go.Scatter3d(
                x=path_x2, y=path_y2, z=path_z2, name='Recocido', mode='markers', 
                marker=dict(color=np.linspace(0, 1, len(path_x1)), colorscale="Viridis", size=4)
            ),
        ], layout=go.Layout(
            scene_aspectmode='manual', 
            scene_aspectratio=dict(x=1, y=nr/nc, z=max(mars_map.max()/x.max(), 0.2)), 
            scene_zaxis_range=[0, mars_map.max()]
        ))

#fig.show()
pio.write_html(fig, file='mapa_marte.html', auto_open=True)

